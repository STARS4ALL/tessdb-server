#!/usr/bin/env python

# GENERATE IDA-FORMAT OBSERVATIONS FILE

# ----------------------------------------------------------------------
# Copyright (c) 2017 Rafael Gonzalez.
#
# See the LICENSE file for details
# ----------------------------------------------------------------------

#--------------------
# System wide imports
# -------------------
from __future__ import generators    # needs to be at the top of your module

import os
import os.path
import sys
import argparse
import sqlite3
import datetime
import time

#--------------
# other imports
# -------------

import jinja2
import pytz
from tessdb.sqlite3.utils import UNKNOWN

# ----------------
# Module constants
# ----------------

UNKNOWN = "Unknown"

DEFAULT_DBASE = "/var/dbase/tess.db"
DEFAULT_TMPLT = "/etc/tessdb/IDA-template.j2"
DEFAULT_DIR   = "/var/dbase/reports/IDA"
DEFAULT_MONTH = datetime.datetime.utcnow().strftime("%Y-%m")

TSTAMP_FORMAT = "%Y-%m-%dT%H:%M:%S.000"

# -----------------------
# Module global functions
# -----------------------

def createParser():
    # create the top-level parser
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('name', metavar='<name>', help='TESS instrument name')
    parser.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    parser.add_argument('-t', '--template', default=DEFAULT_TMPLT, help='Jinja2 template file path')
    parser.add_argument('-o', '--out_dir', default=DEFAULT_DIR, help='Output directory to dump record')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-m', '--for-month', type=mkmonth, default=DEFAULT_MONTH, metavar='<YYYY-MM>', help='Starting year & month. Defaults to current.')
    group.add_argument('-l', '--latest-month', action='store_true', help='Latest month only.')
    return parser

# ------------------
# DATABASE FUNCTIONS
# ------------------

def open_database(dbase_path):
    if not os.path.exists(dbase_path):
       raise IOError("No SQLite3 Database file found at {0}. Exiting ...".format(dbase_path))
    return sqlite3.connect(dbase_path)


def result_iterator(cursor, arraysize=500):
    'An iterator that uses fetchmany to keep memory usage down'
    while True:
        results = cursor.fetchmany(arraysize)
        if not results:
            break
        for result in results:
            yield result


def get_metadata(connection, options):
    cursor = connection.cursor()
    row = {'name': options.name}
    cursor.execute(
            '''
            SELECT name, channel, model, firmware, mac_address,
                    zero_point, cover_offset, filter, fov, azimuth, altitude,
                    contact_name, organization,
                    site, longitude, latitude, elevation, location, province, country, timezone
            FROM tess_v
            WHERE valid_state == "Current"
            AND   name == :name
            ''', row)
    # Solo para instrumentos TESS monocanal
    result = cursor.fetchone()
    instrument = {
        'name':         result[0],
        'channel':      result[1],
        'model':        result[2],
        'firmware':     result[3],
        'mac_address':  result[4],
        'zero_point':   result[5],
        'cover_offset': result[6],
        'filter':       result[7],
        'fov':          result[8],
        'azimuth':      result[9],
        'altitude':     result[10],
    }
    location = {
        'contact_name'   : result[11],
        'organization'   : result[12],
        'site'           : result[13],
        'longitude'      : result[14],
        'latitude'       : result[15],
        'elevation'      : result[16],
        'location'       : result[17],
        'province'       : result[18],
        'country'        : result[19],
        'timezone'       : result[20],
        
    }
    return instrument, location



def count_latest_dbreadings(connection, options):
    '''From start of month at midday UTC'''
    row = {'name': options.name}
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT COUNT (r.frequency), (d.sql_date || 'T' || t.time || '.000') AS timestamp
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN tess_t     as i USING (tess_id)
        WHERE i.name == :name
        AND datetime(timestamp) BETWEEN datetime('now', 'start of month', '+12 hours' ) 
                                AND datetime('now')
        ''', row)
    result = cursor.fetchone()
    print(result)
    return result[0]


def count_dbreadings_for_month(connection, options):
    '''From start of month at midday UTC'''
    row = {'name': options.name, 'from_date': options.for_month.strftime(TSTAMP_FORMAT)}
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT COUNT(r.frequency), (d.sql_date || 'T' || t.time || '.000') AS timestamp
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN tess_t     as i USING (tess_id)
        WHERE i.name == :name
        AND datetime(timestamp) BETWEEN datetime(:from_date) AND datetime(:from_date, '+1 month', '-1 day')
        ''', row)
    result = cursor.fetchone()
    print(result)
    return result[0]


def fetch_latest_dbreadings(connection, options):
    '''From start of month at midday UTC'''
    row = {'name': options.name}
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT (d.sql_date || 'T' || t.time || '.000') AS timestamp, r.ambient_temperature, r.sky_temperature, r.frequency, r.magnitude, i.zero_point
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN tess_t     as i USING (tess_id)
        WHERE i.name == :name
        AND datetime(timestamp) BETWEEN datetime('now', 'start of month', '+12 hours' ) 
                                AND datetime('now')
        ORDER BY r.date_id ASC, r.time_id ASC
        ''', row)
    return cursor


def fetch_dbreadings_for_month(connection, options):
    '''From start of month at midday UTC'''
    row = {'name': options.name, 'from_date': options.for_month.strftime(TSTAMP_FORMAT)}
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT (d.sql_date || 'T' || t.time || '.000') AS timestamp, r.ambient_temperature, r.sky_temperature, r.frequency, r.magnitude, i.zero_point
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN tess_t     as i USING (tess_id)
        WHERE i.name == :name
        AND datetime(timestamp) BETWEEN datetime(:from_date) AND datetime(:from_date, '+1 month', '-1 day')
        ORDER BY r.date_id ASC, r.time_id ASC
        ''', row)
    return cursor
    

# -------------------
# AUXILIARY FUNCTIONS
# -------------------

def render_readings(dbreading, timezone):
    tzobj = pytz.timezone(timezone)
    dt = datetime.datetime.strptime(dbreading[0], TSTAMP_FORMAT).replace(tzinfo=pytz.utc)
    record = {
            'utc':  dbreading[0], 
            'local': dt.astimezone(tzobj).strftime(TSTAMP_FORMAT),
            'tamb': dbreading[1], 
            'tsky': dbreading[2], 
            'freq': dbreading[3], 
            'mag':  dbreading[4],
            'zp':   dbreading[5],
        }
    return "%(utc)s;%(local)s;%(tamb)s;%(tsky)s%(freq)s;%(mag)s;%(zp)s" % record


def mkmonth(datestr):
    return datetime.datetime.strptime(datestr, '%Y-%m').replace(hour=12)


def render(template_path, context):
    if not os.path.exists(template_path):
        raise IOError("No Jinja2 template file found at {0}. Exiting ...".format(template_path))
    path, filename = os.path.split(template_path)
    return jinja2.Environment(
        loader=jinja2.FileSystemLoader(path or './')
    ).get_template(filename).render(context)


def create_directories(instrument_name, out_dir, year=None):
    sub_dir = os.path.join(out_dir, instrument_name)
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)
    if not os.path.exists(sub_dir):
        os.makedirs(sub_dir)
   
# -------------------
# IDA FILE Generation
# -------------------

def write_IDA_header_file(result, instrument_name, out_dir, timestamp):
    '''Writes the IDA header file after contained in result'''
    file_name = instrument_name + timestamp.strftime("_%Y-%m.dat")
    full_name = os.path.join(out_dir, instrument_name, file_name)
    with open(full_name, 'w') as outfile:
        outfile.write(result)

def write_IDA_body_file(result, instrument_name, out_dir, timestamp):
    file_name = instrument_name + timestamp.strftime("_%Y-%m.dat")
    full_name = os.path.join(out_dir, instrument_name, file_name)
    with open(full_name, 'a') as outfile:
        outfile.write(result)
        outfile.write('\n')

# -------------
# MAIN FUNCTION
# -------------

def main():
    '''
    Utility entry point
    '''
    try:
        options = createParser().parse_args(sys.argv[1:])
        connection = open_database(options.dbase)
        if options.latest_month:
            empty = count_latest_dbreadings(connection, options) == 0
        else:
            empty = count_dbreadings_for_month(connection, options) == 0
        if empty:
            print("skipping subdirs creation and IDA file generation")
        else:
            create_directories(options.name, options.out_dir)
            if options.latest_month:
                timestamp  = datetime.datetime.utcnow()
                cursor = fetch_latest_dbreadings(connection, options)
            else:
                timestamp  = options.for_month
                cursor = fetch_dbreadings_for_month(connection, options)
            # render IDA header file from Jinja2 template
            context = {}
            context['instrument'], context['location'] = get_metadata(connection, options)
            timezone = context['location']['timezone']
            header = render(options.template, context).encode('utf-8')
            write_IDA_header_file(header, options.name, options.out_dir, timestamp)
            # render IDA body file by doing direct I/O
            for reading in result_iterator(cursor):
                body_line = render_readings(reading, timezone)
                write_IDA_body_file(body_line, options.name, options.out_dir, timestamp)
    except KeyboardInterrupt:
        print('Interrupted by user ^C')
    except Exception as e:
        print("Error => {0}".format(e))

main()
