#!/usr/bin/env python

# GENERATE IDA-FORMAT OBSERVATIONS FILE

# ----------------------------------------------------------------------
# Copyright (c) 2017 Rafael Gonzalez.
#
# See the LICENSE file for details
# ----------------------------------------------------------------------

#--------------------
# System wide imports
# -------------------

import os
import os.path
import sys
import argparse
import sqlite3
import datetime

#--------------
# other imports
# -------------

import jinja2
import pytz
from tessdb.sqlite3.utils import UNKNOWN

# ----------------
# Module constants
# ----------------

DEFAULT_DBASE = "/var/dbase/tess.db"
DEFAULT_TMPLT = "/etc/tessdb/IDA-template.j2"

TSTAMP_FORMAT = "%Y-%m-%dT%H:%M:%S.000"

# -----------------------
# Module global functions
# -----------------------

def createParser():
    # create the top-level parser
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('name', metavar='<name>', help='TESS instrument name')
    parser.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    parser.add_argument('-t', '--template', default=DEFAULT_TMPLT, help='Jinja2 template file path')
    return parser



# ------------------
# DATABASE FUNCTIONS
# ------------------

def paging(cursor, headers, size=10):
    '''
    Pages query output and displays in tabular format
    '''
    ONE_PAGE = 10
    while True:
        result = cursor.fetchmany(ONE_PAGE)
        print tabulate.tabulate(result, headers=headers, tablefmt='grid')
        if len(result) < ONE_PAGE:
            break
        size -= ONE_PAGE
        if size > 0:
            raw_input("Press Enter to continue [Ctrl-C to abort] ...")
        else:
            break

def get_metadata(connection, options):
    cursor = connection.cursor()
    row = {'name': options.name}
    cursor.execute(
            '''
            SELECT name, channel, model, firmware, mac_address,
                    zero_point, cover_offset, filter, fov, 
                    contact_name, organization,
                    site, longitude, latitude, elevation, location, province, country, timezone
            FROM tess_v
            WHERE valid_state == "Current"
            AND   name == :name
            ''', row)
    # Solo para instrumentos TESS monocanal
    result = cursor.fetchone()
    instrument = {
        'name':         result[0],
        'channel':      result[1],
        'model':        result[2],
        'firmware':     result[3],
        'mac_address':  result[4],
        'zero_point':   result[5],
        'cover_offset': result[6],
        'filter':       result[7],
        'fov':          result[8],
    }
    location = {
        'contact_name'   : result[9],
        'organization'   : result[10],
        'site'           : result[11],
        'longitude'      : result[12],
        'latitude'       : result[13],
        'elevation'      : result[14],
        'location'       : result[15],
        'province'       : result[16],
        'country'        : result[17],
        'timezone'       : result[18],
        
    }
    return instrument, location

def get_readings(connection, options, timezone):
    row = {'name': options.name}
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT (d.sql_date || 'T' || t.time || '.000') AS timestamp, r.ambient_temperature, r.sky_temperature, r.frequency, r.magnitude
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN tess_t     as i USING (tess_id)
        WHERE i.name == :name
        AND   i.valid_state == "Current"
        ORDER BY r.date_id DESC, r.time_id DESC
        ''', row)
    readings = []
    results = cursor.fetchmany(50)
   
    for result in results:
            kk = {'utc': result[0], 'tamb': result[1], 'tsky': result[2], 'freq': result[3], 'mag': result[4]}
            tzobj = pytz.timezone(timezone)
            dt = datetime.datetime.strptime(kk['utc'], TSTAMP_FORMAT).replace(tzinfo=pytz.utc)
            kk['local'] = dt.astimezone(tzobj).strftime(TSTAMP_FORMAT)
            readings.append(kk)
    return readings


# -------------------
# AUXILIARY FUNCTIONS
# -------------------

def open_database(dbase_path):
    if not os.path.exists(dbase_path):
       raise IOError("No SQLite3 Database file found at {0}. Exiting ...".format(dbase_path))
    return sqlite3.connect(dbase_path)


def render(template_path, context):
    if not os.path.exists(template_path):
        raise IOError("No Jinja2 template file found at {0}. Exiting ...".format(template_path))
    path, filename = os.path.split(template_path)
    return jinja2.Environment(
        loader=jinja2.FileSystemLoader(path or './')
    ).get_template(filename).render(context)

# -------------
# MAIN FUNCTION
# -------------

def main():
    '''
    Utility entry point
    '''
    try:
        options = createParser().parse_args(sys.argv[1:])
        connection = open_database(options.dbase)
        context = {}
        context['instrument'], context['location'] = get_metadata(connection, options)
        context['readings'] = get_readings(connection, options, context['location']['timezone'])
        result=render(options.template, context)
        print(result)
    except KeyboardInterrupt:
        print('')
    except Exception as e:
        print("Error => {0}".format(e))

main()
