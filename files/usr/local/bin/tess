#!/usr/bin/env python

# TESS UTILITY TO PERFORM SOME MAINTENANCE COMMANDS

# ----------------------------------------------------------------------
# Copyright (c) 2014 Rafael Gonzalez.
#
# See the LICENSE file for details
# ----------------------------------------------------------------------

#--------------------
# System wide imports
# -------------------

import sys
import argparse
import sqlite3
import os
import os.path
import json
import datetime

#--------------
# other imports
# -------------

import tabulate
from tessdb.sqlite3.utils import CURRENT, UNKNOWN

# ----------------
# Module constants
# ----------------


if os.name == "nt":
    DEFAULT_DBASE = r"C:\tesdb\dbase\tess.db"
else:
    DEFAULT_DBASE = "/var/dbase/tess.db"


INFINITE_TIME = "2999-12-31T23:59:59"
EXPIRED       = "Expired"
CURRENT       = "Current"
TSTAMP_FORMAT = "%Y-%m-%dT%H:%M:%S"

# Default values for Zer Point and Filter type
UNKNOWN_ZP     = -99
DEFAULT_ZP     = 20.5   #  TESS magnitudes / arcsec^2
UNKNOWN_FILTER = "Unknown"
DEFAULT_FILTER = "UVIR"   # Dichroic Glass

# -----------------------
# Module global variables
# -----------------------

# -----------------------
# Module global functions
# -----------------------

def createParser():
    # create the top-level parser
    parser = argparse.ArgumentParser(prog=sys.argv[0])

    subparser = parser.add_subparsers()

    # --------------------------
    # Create first level parsers
    # --------------------------
    parser_instrument = subparser.add_parser('instrument', help='instrument commands')
    parser_location   = subparser.add_parser('location', help='location commands')
    parser_readings   = subparser.add_parser('readings', help='readings commands')

    # ------------------------------------------
    # Create second level parsers for 'location'
    # ------------------------------------------
    # Choices:
    #   tess location list
    #
    subparser = parser_location.add_subparsers()
    llp = subparser.add_parser('list', help='list locations')
    llp.add_argument('-p', '--page-size', type=int, default=10, help='list page size')
    llp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    lcp = subparser.add_parser('create', help='create location')
    lcp.add_argument('site', metavar='<site>', help='Unique site name')
    lcp.add_argument('-o', '--longitude', type=float, default=0.0,       help='geographical longitude (degrees)')
    lcp.add_argument('-a', '--latitude',  type=float, default=0.0,       help='geographical latitude (degrees)')
    lcp.add_argument('-e', '--elevation', type=float, default=0.0,       help='elevation above sea level(meters)')
    lcp.add_argument('-z', '--zipcode',   type=str,   default='Unknown', help='Postal Code')
    lcp.add_argument('-l', '--location',  type=str,   default='Unknown', help='Location (village, town, city)')
    lcp.add_argument('-p', '--province',  type=str,   default='Unknown', help='Province')
    lcp.add_argument('-c', '--country',   type=str,   default='Unknown', help='Country')
    lcp.add_argument('-o', '--owner',     type=str,   default='Unknown', help='Contact person')
    lcp.add_argument('-m', '--email',     type=str,   default='Unknown', help='Contact email')
    lcp.add_argument('-t', '--tzone',     type=str,   default='Etc/UTC', help='Olson Timezone')
    lcp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    lup = subparser.add_parser('update', help='update location')
    lup.add_argument('site', metavar='<site>', help='Unique site name')
    lup.add_argument('-o', '--longitude', type=float, default=-999.0,    help='geographical longitude (degrees)')
    lup.add_argument('-a', '--latitude',  type=float, default=-999.0,    help='geographical latitude (degrees)')
    lup.add_argument('-e', '--elevation', type=float, default=-999.0,    help='elevation above sea level(meters)')
    lup.add_argument('-z', '--zipcode',   type=str,   default='Unknown', help='Postal Code')
    lup.add_argument('-l', '--location',  type=str,   default='Unknown', help='Location (village, town, city)')
    lup.add_argument('-p', '--province',  type=str,   default='Unknown', help='Province')
    lup.add_argument('-c', '--country',   type=str,   default='Unknown', help='Country')
    lup.add_argument('-o', '--owner',     type=str,   default='Unknown', help='Contact person')
    lup.add_argument('-m', '--email',     type=str,   default='Unknown', help='Contact email')
    lcp.add_argument('-t', '--tzone',     type=str,   default='Etc/UTC', help='Olson Timezone')
    lup.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    lre = subparser.add_parser('rename', help='rename location')
    lre.add_argument('old_site',  type=str, help='old site name')
    lre.add_argument('new_site',  type=str, help='new site name')
    lre.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    # ------------------------------------------
    # Create second level parsers for 'readings'
    # ------------------------------------------
    # Choices:
    #   tess location list
    #
    subparser = parser_readings.add_subparsers()
    rp = subparser.add_parser('list', help='list readings')
    rp.add_argument('-c', '--count', type=int, default=10, help='list up to <count> entries')
    rp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    # --------------------------------------------
    # Create second level parsers for 'instrument'
    # --------------------------------------------
    # Choices:
    #   tess instrument list
    #   tess instrument assign <instrument name> <location name>
    #   tess instrument export
    #   tess instrument import
    #   tess instrument create <friendly name> <MAC address> <Calibration Constant>
    #   tess instrument rename <old friendly name> <new friendly name>
    #   tess instrument update <friendly name> --zero-point <new zero point> --filter <new filter> --latest
    #   tess instrument delete <instrument name> 
    #
    subparser = parser_instrument.add_subparsers()
    parser_instrument_assign = subparser.add_parser('assign', help='assign instrument to location')
    parser_instrument_assign.add_argument('instrument', metavar='<instrument>', help='TESS instrument name')
    parser_instrument_assign.add_argument('location',   metavar='<location>',   help='Location name')
    parser_instrument_assign.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    ip = subparser.add_parser('list', help='list instruments')
    ip.add_argument('-p', '--page-size', type=int, default=10, help='list page size')
    ip.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    ip.add_argument('-l', '--log', action='store_true', default=False, help='show TESS instrument change log')

    xp = subparser.add_parser('export', help='export instruments to JSON')
    xp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    xp.add_argument('-f', '--file', type=str, default="tess.json", help='exported JSON file')

    imp = subparser.add_parser('import', help='import instruments from JSON')
    imp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    imp.add_argument('-f', '--file', type=str, default="tess.json", help='source JSON file')

    ihi = subparser.add_parser('history',  help='single instrument history')
    ihi.add_argument('name',   type=str,   help='friendly name')
    ihi.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    icr = subparser.add_parser('create',   help='create instrument')
    icr.add_argument('name',   type=str,   help='friendly name')
    icr.add_argument('mac',    type=str,   help='MAC address')
    icr.add_argument('zp',     type=float, help='Zero Point')
    icr.add_argument('filter', type=str,   help='Filter (i.e. DG, BG39, GG495, etc.)')
    icr.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    ire = subparser.add_parser('rename', help='rename instrument')
    ire.add_argument('old_name',  type=str, help='old friendly name')
    ire.add_argument('new_name',  type=str, help='new friendly name')
    ire.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    ide = subparser.add_parser('delete', help='delete instrument')
    ide.add_argument('name',  type=str, help='instrument friendly name')
    ide.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    iup = subparser.add_parser('update',   help='update instrument zero point and/or filter')
    iup.add_argument('name',   type=str,   help='instrument friendly name')
    iup.add_argument('-z', '--zero-point', default=UNKNOWN_ZP,  type=float, help='new zero point')
    iup.add_argument('-f', '--filter', default=UNKNOWN_FILTER,  type=str,  help='new filter glass')
    iup.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    iupex = iup.add_mutually_exclusive_group()
    now = datetime.datetime.utcnow().strftime(TSTAMP_FORMAT)
    iupex.add_argument("-s", "--start-time", type=str, default=now, metavar="YYYYMMDDTHHMMSS", help='update start date')
    iupex.add_argument('-l', '--latest', action='store_true', default=False, help='Latest entry only (no change control)')
    
    return parser

def main():
    '''
    Utility entry point
    '''
    try:
        options = createParser().parse_args(sys.argv[1:])
        connection = open_database(options)
        if   sys.argv[1] == 'instrument' and sys.argv[2] == 'list':
            instrument_list(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'assign':
            instrument_assign(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'export':
            instrument_export(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'import':
            instrument_import(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'create':
            instrument_create(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'rename':
            instrument_rename(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'delete':
            instrument_delete(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'update':
            instrument_update(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'history':
            instrument_single_history(connection, options)
        elif sys.argv[1] == 'location' and sys.argv[2] == 'list':
            location_list(connection, options)
        elif sys.argv[1] == 'location' and sys.argv[2] == 'create':
            location_create(connection, options)
        elif sys.argv[1] == 'location' and sys.argv[2] == 'update':
            location_update(connection, options)
        elif sys.argv[1] == 'location' and sys.argv[2] == 'rename':
            location_rename(connection, options)
        elif sys.argv[1] == 'readings' and sys.argv[2] == 'list':
            readings_list(connection, options)
    except KeyboardInterrupt:
        print('')
    except Exception as e:
        print("Error => {0}".format(e))

# ==============
# DATABASE STUFF
# ==============

def open_database(options):
    if not os.path.exists(options.dbase):
        raise IOError("No SQLite3 Database file found in {0}. Exiting ...".format(options.dbase))
    return sqlite3.connect(options.dbase)
 

def paging(cursor, headers, size=10):
    '''
    Pages query output and displays in tabular format
    '''
    ONE_PAGE = 10
    while True:
        result = cursor.fetchmany(ONE_PAGE)
        print tabulate.tabulate(result, headers=headers, tablefmt='grid')
        if len(result) < ONE_PAGE:
            break
        size -= ONE_PAGE
        if size > 0:
            raw_input("Press Enter to continue [Ctrl-C to abort] ...")
        else:
            break

# ----------------------
# INSTRUMENT SUBCOMMANDS
# ----------------------

def instrument_assign(connection, options):
    cursor = connection.cursor()
    row = {'site': options.location, 'tess': options.instrument, 'state': CURRENT}
    cursor.execute("SELECT location_id FROM location_t WHERE site == :site",row)
    res =  cursor.fetchone()
    if not res:
        print("Location not found by {0}".format(row['site']))
        sys.exit(1)
    row['ident'] = res[0]
    cursor.execute(
        '''
        UPDATE tess_t SET location_id = :ident
        WHERE name == :tess
        ''', row)
    cursor.execute(
        '''
        SELECT name,site,longitude,latitude,elevation 
        FROM tess_v
        WHERE valid_state == :state
        AND name = :tess
        ''',row)
    paging(cursor,["TESS","Site","Longitude","Latitude","Elevation"])
    connection.commit()    


def instrument_single_history(connection, options):
    cursor = connection.cursor()
    row = {'tess': options.name }
    cursor.execute(
            '''
            SELECT name,tess_id,mac_address,zero_point,filter,valid_since,valid_until
            FROM tess_t
            WHERE name = :tess
            ORDER BY tess_t.valid_since ASC;
            ''',row)
    paging(cursor,["TESS","Id","MAC Addr.","Zero Point","Filter","Since","Until"], size=100)


def instrument_list(connection, options):
    if options.log:
        instrument_historic_list(connection, options)
    else:
        instrument_current_list(connection, options)

def instrument_historic_list(connection, options):
    cursor = connection.cursor()
    cursor.execute(
            '''
            SELECT name,mac_address,zero_point,filter,site,longitude,latitude,elevation,valid_since,valid_until
            FROM tess_v
            ORDER BY CAST(substr(tess_v.name, 6) as decimal) ASC, tess_v.valid_since ASC;
            ''')
    paging(cursor,["TESS","MAC Addr.","Zero Point","Filter","Site","Longitude","Latitude","Elevation","Since","Until"], size=100)


def instrument_current_list(connection, options):
    cursor = connection.cursor()
    row = {'state': CURRENT}
    cursor.execute(
            '''
            SELECT name,mac_address,zero_point,filter,site,longitude,latitude,elevation 
            FROM tess_v
            WHERE valid_state == :state
            ORDER BY CAST(substr(tess_v.name, 6) as decimal) ASC;
            ''', row)
    paging(cursor,["TESS","MAC Addr.","Zero Point","Filter","Site","Longitude","Latitude","Elevation"], size=100)


def instrument_export(connection, options):

    def instrument_map(item):
        return {
            'tess_id':     item[0], 
            'name':        item[1], 
            'mac_address': item[2], 
            'zero_point':  item[3],
            'filter':      item[4], 
            'valid_since': item[5], 
            'valid_until': item[6], 
            'valid_state': item[7], 
            'location_id': item[8],
        }

    cursor = connection.cursor()
    cursor.execute(
            '''
            SELECT tess_id,name,mac_address,zero_point,filter,valid_since,valid_until,valid_state,location_id 
            FROM tess_t
            ORDER BY tess_id ASC;
            ''')
    result = cursor.fetchall()
    with open(options.file, 'w') as outfile:
        json.dump(map(instrument_map, result), outfile, indent=4, sort_keys=True)


def instrument_import(connection, options):
    cursor = connection.cursor()
    with open(options.file, 'r') as outfile:
        rows = json.load(outfile)
    cursor.executemany(
        '''INSERT OR REPLACE INTO tess_t (
            tess_id,
            name,
            mac_address,
            zero_point,
            filter,
            valid_since,
            valid_until,
            valid_state,
            location_id
        ) VALUES (
            :tess_id,
            :name,
            :mac_address,
            :zero_point,
            :filter,
            :valid_since,
            :valid_until,
            :valid_state,
            :location_id
        )
        ''', rows)
    connection.commit()


def instrument_create(connection, options):
    cursor = connection.cursor()
    row = {}
    row['name']       = options.name
    row['mac']        = options.mac
    row['zp']         = options.zp
    row['filter']     = options.filter
    row['valid_flag'] = CURRENT
    row['eff_date']   = datetime.datetime.utcnow().strftime(TSTAMP_FORMAT)
    row['exp_date']   = INFINITE_TIME
    
    # Find existing MAC and abort if so
    cursor.execute(
        '''
        SELECT name, mac_address
        FROM tess_t 
        WHERE mac_address == :mac
        AND valid_state == :valid_flag
        ''', row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Already existing MAC %s" % (row['mac'],) )
    # Find existing name and abort if so
    cursor.execute(
        '''
        SELECT name, mac_address
        FROM tess_t 
        WHERE name == :name
        AND valid_state == :valid_flag 
        ''', row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Other instrument already using friendly name %s" (row['name'],) )
    # Write into database
    cursor.execute(
        '''
        INSERT INTO tess_t (
            name,
            mac_address, 
            zero_point,
            filter,
            valid_since,
            valid_until,
            valid_state
        ) VALUES (
            :name,
            :mac,
            :zp,
            :filter,
            :eff_date,
            :exp_date,
            :valid_flag
        )
        ''',  row)
    connection.commit()
    # Now display it
    cursor.execute(
        '''
        SELECT name, mac_address, zero_point, filter, site, longitude, latitude, elevation 
        FROM   tess_v
        WHERE  name == :name
        AND    valid_state == :valid_flag
        ''', row)
    paging(cursor,["TESS","MAC Addr.","Calibration","Filter","Site","Longitude","Latitude","Elevation"])



def instrument_rename(connection, options):
    cursor = connection.cursor()
    row = {}
    row['newname']  = options.new_name
    row['oldname']  = options.old_name
    cursor.execute("SELECT mac_address FROM tess_t WHERE name == :oldname", row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing instrument with old name %s does not exist." 
            % (options.old_name,) )
    cursor.execute("SELECT mac_address FROM tess_t WHERE name == :newname", row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Cannot rename. Existing instrument MAC %s owns this name." % (result[0],) ) 
    cursor.execute("UPDATE tess_t SET name = :newname WHERE name == :oldname", row)
    connection.commit()
    # Now display it
    row['valid_flag'] = CURRENT
    cursor.execute(
        '''
        SELECT name,mac_address,zero_point,filter,site,longitude,latitude,elevation 
        FROM   tess_v
        WHERE  name == :newname
        AND    valid_state == :valid_flag
        ''', row)
    paging(cursor,["TESS","MAC Addr.","Zero Point","Filter","Site","Longitude","Latitude","Elevation"])


def instrument_delete(connection, options):
    cursor = connection.cursor()
    row = {}
    row['name']  = options.name

    cursor.execute("SELECT mac_address FROM tess_t WHERE name == :name", row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot delete. Instrument with name %s does not exist." 
            % (options.name,) )
    
    # Find out what's being deleted
    print("About to delete")
    cursor.execute(
        '''
        SELECT name,mac_address,zero_point,filter,site,longitude,latitude,elevation 
        FROM   tess_v
        WHERE  name == :name
        ''', row)
    paging(cursor,["TESS","MAC Addr.","Zero Point","Filter","Site","Longitude","Latitude","Elevation"])
    
    # Find out if it has accumulated readings
    # This may go away if readings are stored in another database (i.e influxdb)
    cursor.execute(
        '''
        SELECT i.name, count(*) AS readings
        FROM tess_readings_t AS r
        JOIN tess_t          AS i USING (tess_id)
        WHERE i.name == :name
        ''', row)
    paging(cursor,["TESS","Acumulated Readings"])
    raw_input("Are you sure ???? Press Enter to continue [Ctrl-C to abort] ...")

    cursor.execute("DELETE FROM tess_t WHERE name == :name", row)
    connection.commit()
    print("Instrument deleted")


def instrument_update(connection, options):
    if options.zero_point == UNKNOWN_ZP and options.filter == UNKNOWN_FILTER:
        raise ValueError("No Zero Point or Filter was specified.")
    
    if options.latest:
        instrument_raw_update(connection, options)
    else:
        try:
            datetime.datetime.strptime(options.start_time, TSTAMP_FORMAT)
        except ValueError as e:
            print("Invalid start date YYYY-MM-DDTHH:MM:SS format: => %s" % (options.start_time,) )
        else:
            instrument_controlled_update(connection, options)


def instrument_raw_update(connection, options):
    '''Raw update lastest instrument calibration constant (with 'Current' state)'''
    cursor = connection.cursor()
    row = {}
    row['name']       = options.name
    row['valid_flag'] = CURRENT
    cursor.execute(
        '''
        SELECT name, mac_address, location_id 
        FROM tess_t 
        WHERE name == :name
        AND valid_state == :valid_flag 
        ''', row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing instrument with name %s does not exist."
         % (options.name,) )
    row['mac']           = result[1]

    # Change only if passed in the command line
    if options.zero_point != UNKNOWN_ZP:
        row['zp']            = options.zero_point
        cursor.execute(
        '''
        UPDATE tess_t SET zero_point = :zp
        WHERE mac_address == :mac AND valid_state == :valid_flag
        ''', row)

    if options.filter != UNKNOWN_FILTER:
        row['filter']            = options.filter
        cursor.execute(
        '''
        UPDATE tess_t SET filter = :filter
        WHERE mac_address == :mac AND valid_state == :valid_flag
        ''', row)

    connection.commit()
    print("Operation complete.")
    cursor.execute(
        '''
        SELECT name, zero_point, filter, valid_state, valid_since, valid_until, site
        FROM   tess_v
        WHERE  name == :name AND valid_state == :valid_flag 
        ''', row)
    paging(cursor,["TESS","Zero Point","Filter","State","Since","Until", "Site"])




def instrument_controlled_update(connection, options):
    '''
    Update lastest instrument calibration constant with control change
    creating a new row with new calibration state and valid interval
    '''
    cursor = connection.cursor()
    row = {}
    row['name']       = options.name
    row['valid_flag'] = CURRENT
    cursor.execute(
        '''
        SELECT name, mac_address, location_id, valid_since 
        FROM tess_t 
        WHERE name == :name
        AND valid_state == :valid_flag 
        ''', row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing instrument with name %s does not exist." % (options.name,) )
    if result[3] >= options.start_time:
        raise ValueError("Cannot set valid_since (%s) column to an equal or earlier date (%s)" % (result[3], options.start_time) )

    row['mac']           = result[1]
    row['location']      = result[2]
    row['eff_date']      = options.start_time
    row['exp_date']      = INFINITE_TIME
    row['valid_expired'] = EXPIRED
    row['zp']            = DEFAULT_ZP if options.zero_point == UNKNOWN_ZP else options.zero_point
    row['filter']        = DEFAULT_FILTER if options.filter == UNKNOWN_FILTER else options.filter

    cursor.execute(
        '''
        UPDATE tess_t SET valid_until = :eff_date, valid_state = :valid_expired
        WHERE mac_address == :mac AND valid_state == :valid_flag
        ''', row)

    cursor.execute(
        '''
        INSERT INTO tess_t (
            name,
            mac_address, 
            zero_point,
            filter,
            valid_since,
            valid_until,
            valid_state,
            location_id
        ) VALUES (
            :name,
            :mac,
            :zp,
            :filter,
            :eff_date,
            :exp_date,
            :valid_flag,
            :location
            )
        ''',  row)
    connection.commit()
    print("Operation complete.")
    
    cursor.execute(
        '''
        SELECT name, zero_point, filter, valid_state, valid_since, valid_until, site
        FROM   tess_v
        WHERE  name == :name
        ''', row)
    paging(cursor,["TESS","Zero Point","Filter","State","Since","Until", "Site"])


# --------------------
# LOCATION SUBCOMMANDS
# --------------------

def location_list(connection, options):
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT site,longitude,latitude,elevation 
        FROM location_t 
        WHERE location_id > -1 
        ORDER BY location_id ASC
        ''')
    paging(cursor,["Name","Longitude","Latitude","Elevation"], size=100)

# Location update is a nightmare ifdone properly, since we have to generate
# SQL updates tailored to the attributes being given in the command line

def location_create(connection, options):
    cursor = connection.cursor()
    row = {}
    row['site']      = options.site
    row['longitude'] = options.longitude
    row['latitude']  = options.latitude
    row['elevation'] = options.elevation
    row['zipcode']   = options.zipcode
    row['location']  = options.location
    row['province']  = options.province
    row['country']   = options.country
    row['email']     = options.email
    row['owner']     = options.owner
    row['tzone']     = options.tzone
    # Fetch existing site
    cursor.execute(
        '''
        SELECT site 
        FROM   location_t 
        WHERE site == :site
        ''', row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Cannot create. Existing site with name %s already exists." % (options.site,) )
    cursor.execute(
        '''
        INSERT INTO location_t (
            site,
            longitude, 
            latitude,
            elevation,
            zipcode,
            location,
            province,
            country,
            contact_email,
            contact_name,
            timezone
        ) VALUES (
            :site,
            :longitude,
            :latitude,
            :elevation,
            :zipcode,
            :location,
            :province,
            :country,
            :email,
            :owner,
            :tzone
            )
        ''',  row)
    connection.commit()
    # Read just written data
    cursor.execute(
        '''
        SELECT site,longitude,latitude,elevation,contact_person,contact_email,zipcode,location,province,country,timezone
        FROM location_t 
        WHERE site == :site
        ORDER BY location_id ASC
        ''', row)
    paging(cursor,["Name","Longitude","Latitude","Elevation","Contact","Email","ZIP Code","Location","Province","Country","Timezone"], size=5)


def location_dynamic_update(options):
    row = {} 
    fmt = []
    row['site'] = options.site
    if options.longitude != -999.0:
        row['longitude'] = options.longitude
        fmt.append("longitude = :longitude")
    if options.latitude != -999.0:
        row['latitude']  = options.latitude
        fmt.append("latitude = :latitude")
    if options.elevation != -999.0 :
        row['elevation'] = options.elevation
        fmt.append("elevation = :elevation")
    if options.zipcode != 'Unknown':
        row['zipcode']   = options.zipcode
        fmt.append("zipcode = :zipcode")
    if options.location != 'Unknown':
        row['location']  = options.location
        fmt.append("location = :location")
    if options.province != 'Unknown':
        row['province']  = options.province
        fmt.append("province = :province")
    if options.country != 'Unknown':
        row['country']  = options.country
        fmt.append("country = :country")
    if options.email != 'Unknown':
        row['email']   = options.email
        fmt.append("email = :email")
    if options.owner != 'Unknown':
        row['owner']   = options.owner
        fmt.append("email = :owner")
    if options.tzone != 'Etc/UTC':
        row['tzone']   = options.tzone
        fmt.append("timezone = :tzone")
    return row, fmt


def location_update(connection, options):
    cursor = connection.cursor()
    row, fmt = location_dynamic_update(options)
    # Fetch existing site
    cursor.execute(
        '''
        SELECT site 
        FROM   location_t 
        WHERE site == :site
        ''', row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot update. Site with name %s does not exists." % (options.site,) )
    cursor.execute(
        '''
        UPDATE location_t 
        SET
        ''' + ','.join(fmt) +
        '''
        WHERE site == :site
        ''',  row)
    connection.commit()
    # Read just written data
    cursor.execute(
        '''
        SELECT site,longitude,latitude,elevation,contact_person,contact_email,zipcode,location,province,country,timezone
        FROM location_t 
        WHERE site == :site
        ORDER BY location_id ASC
        ''', row)
    paging(cursor,["Name","Longitude","Latitude","Elevation","Contact","Email","ZIP Code","Location","Province","Country","Timezone"], size=5)


def location_rename(connection, options):
    cursor = connection.cursor()
    row = {}
    row['newsite']  = options.new_site
    row['oldsite']  = options.old_site
    cursor.execute("SELECT site FROM location_t WHERE site == :oldsite", row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing site with old name %s does not exist." 
            % (options.old_site,) )
    
    cursor.execute("SELECT site FROM location_t WHERE site == :newsite", row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Cannot rename. New site %s already exists." % (result[0],) ) 
    cursor.execute("UPDATE location_t SET site = :newsite WHERE site == :oldsite", row)
    connection.commit()
    # Now display it
    cursor.execute(
        '''
        SELECT site,longitude,latitude,elevation,contact_person,contact_email,zipcode,location,province,country,timezone
        FROM location_t 
        WHERE site == :newsite
        ''', row)
    paging(cursor,["Name","Longitude","Latitude","Elevation","Contact","Email","ZIP Code","Location","Province","Country","Timezone"], size=5)

# --------------------
# READINGS SUBCOMMANDS
# --------------------

def readings_list(connection, options):
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT (d.sql_date || 'T' || t.time) AS timestamp, i.name, l.site, r.frequency, r.magnitude
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN location_t as l USING (location_id)
        JOIN tess_t     as i USING (tess_id)
        ORDER BY r.date_id DESC, r.time_id DESC
        LIMIT %s
        ''' % options.count)
    paging(cursor, ["Timestamp (UTC)","TESS","Location","Frequency","Magnitude"], size=options.count)
   
 
main()
