#!/usr/bin/env python

# TESS UTILITY TO PERFORM SOME MAINTENANCE COMMANDS

# ----------------------------------------------------------------------
# Copyright (c) 2014 Rafael Gonzalez.
#
# See the LICENSE file for details
# ----------------------------------------------------------------------

#--------------------
# System wide imports
# -------------------

import sys
import argparse
import sqlite3
import os
import os.path
import json
import datetime

#--------------
# other imports
# -------------

import tabulate
from tessdb.sqlite3.utils import CURRENT, UNKNOWN

# ----------------
# Module constants
# ----------------


if os.name == "nt":
    DEFAULT_DBASE = r"C:\tesdb\dbase\tess.db"
else:
    DEFAULT_DBASE = "/var/dbase/tess.db"


INFINITE_TIME = "2999-12-31T23:59:59"
EXPIRED       = "Expired"
CURRENT       = "Current"
TSTAMP_FORMAT = "%Y-%m-%dT%H:%M:%S"

# -----------------------
# Module global variables
# -----------------------

# -----------------------
# Module global functions
# -----------------------

def createParser():
    # create the top-level parser
    parser = argparse.ArgumentParser(prog=sys.argv[0])

    subparser = parser.add_subparsers()

    # --------------------------
    # Create first level parsers
    # --------------------------
    parser_instrument = subparser.add_parser('instrument', help='instrument commands')
    parser_location   = subparser.add_parser('location', help='location commands')
    parser_readings   = subparser.add_parser('readings', help='readings commands')

    # ------------------------------------------
    # Create second level parsers for 'location'
    # ------------------------------------------
    # Choices:
    #   tess location list
    #
    subparser = parser_location.add_subparsers()
    lp = subparser.add_parser('list', help='list locations')
    lp.add_argument('-p', '--page-size', type=int, default=10, help='list page size')
    lp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')



    # ------------------------------------------
    # Create second level parsers for 'readings'
    # ------------------------------------------
    # Choices:
    #   tess location list
    #
    subparser = parser_readings.add_subparsers()
    rp = subparser.add_parser('list', help='list readings')
    rp.add_argument('-c', '--count', type=int, default=10, help='list up to <count> entries')
    rp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    # --------------------------------------------
    # Create second level parsers for 'instrument'
    # --------------------------------------------
    # Choices:
    #   tess instrument list
    #   tess instrument assign <instrument name> <location name>
    #
    subparser = parser_instrument.add_subparsers()
    parser_instrument_assign = subparser.add_parser('assign', help='assign instrument to location')
    parser_instrument_assign.add_argument('instrument', metavar='<instrument>', help='TESS instrument name')
    parser_instrument_assign.add_argument('location',   metavar='<location>',   help='Location name')
    parser_instrument_assign.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    ip = subparser.add_parser('list', help='list instruments')
    ip.add_argument('-p', '--page-size', type=int, default=10, help='list page size')
    ip.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    xp = subparser.add_parser('export', help='export instruments to JSON')
    xp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    xp.add_argument('-f', '--file', type=str, default="tess.json", help='exported JSON file')

    imp = subparser.add_parser('import', help='import instruments from JSON')
    imp.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')
    imp.add_argument('-f', '--file', type=str, default="tess.json", help='source JSON file')

    icr = subparser.add_parser('create', help='create instrument')
    icr.add_argument('name',  type=str, help='friendly name')
    icr.add_argument('mac',   type=str, help='MAC address')
    icr.add_argument('calib', type=float, help='Calibration Constant')
    icr.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    ire = subparser.add_parser('rename', help='rename instrument')
    ire.add_argument('old_name',  type=str, help='old friendly name')
    ire.add_argument('new_name',   type=str, help='new friendly name')
    ire.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')

    iup = subparser.add_parser('update', help='update instrument calibration constant')
    iup.add_argument('name',   type=str, help='instrument friendly name')
    iup.add_argument('new_value',  type=float, help='new calib constant')
    iup.add_argument('-d', '--dbase', default=DEFAULT_DBASE, help='SQLite database full file path')


    return parser

def main():
    '''
    Utility entry point
    '''
    try:
        options = createParser().parse_args(sys.argv[1:])
        connection = open_database(options)
        if   sys.argv[1] == 'instrument' and sys.argv[2] == 'list':
            instrument_list(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'assign':
            instrument_assign(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'export':
            instrument_export(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'import':
            instrument_import(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'create':
            instrument_create(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'rename':
            instrument_rename(connection, options)
        elif sys.argv[1] == 'instrument' and sys.argv[2] == 'update':
            instrument_update(connection, options)
        elif sys.argv[1] == 'location' and sys.argv[2] == 'list':
            location_list(connection, options)
        elif sys.argv[1] == 'readings' and sys.argv[2] == 'list':
            readings_list(connection, options)
    except KeyboardInterrupt:
        print('')
    except Exception as e:
        print("Error => {0}".format(e))

# ==============
# DATABASE STUFF
# ==============

def open_database(options):
    if not os.path.exists(options.dbase):
        raise IOError("No SQLite3 Database file found in {0}. Exiting ...".format(options.dbase))
    return sqlite3.connect(options.dbase)
 

def paging(cursor, headers, size=10):
    '''
    Pages query output and displays in tabular format
    '''
    ONE_PAGE = 10
    while True:
        result = cursor.fetchmany(ONE_PAGE)
        print tabulate.tabulate(result, headers=headers, tablefmt='grid')
        if len(result) < ONE_PAGE:
            break
        size -= ONE_PAGE
        if size > 0:
            raw_input("Press Enter to continue [Ctrl-C to abort] ...")
        else:
            break

# ----------------------
# INSTRUMENT SUBCOMMANDS
# ----------------------

def instrument_assign(connection, options):
    cursor = connection.cursor()
    row = {'site': options.location, 'tess': options.instrument, 'state': CURRENT}
    cursor.execute("SELECT location_id FROM location_t WHERE site == :site",row)
    res =  cursor.fetchone()
    if not res:
        print("Location not found by {0}".format(row['site']))
        sys.exit(1)
    row['ident'] = res[0]
    cursor.execute(
        '''
        UPDATE tess_t SET location_id = :ident
        WHERE name == :tess
        ''', row)
    cursor.execute(
        '''
        SELECT name,site,longitude,latitude,elevation 
        FROM tess_v
        WHERE calibrated_state == :state
        AND name = :tess
        ''',row)
    paging(cursor,["TESS","Site","Longitude","Latitude","Elevation"])
    connection.commit()    


def instrument_list(connection, options):
    cursor = connection.cursor()
    row = {'state': CURRENT}
    cursor.execute(
            '''
            SELECT name,mac_address,calibration_k,site,longitude,latitude,elevation 
            FROM tess_v
            WHERE calibrated_state == :state
            ORDER BY name ASC;
            ''', row)
    paging(cursor,["TESS","MAC Addr.","Calibration","Site","Longitude","Latitude","Elevation"])

def instrument_map(item):
    return {
        'tess_id':          item[0], 
        'name':             item[1], 
        'mac_address':      item[2], 
        'calibration_k':    item[3], 
        'calibrated_since': item[4], 
        'calibrated_until': item[5], 
        'calibrated_state': item[6], 
        'location_id':      item[7],
        }

def instrument_export(connection, options):
    cursor = connection.cursor()
    cursor.execute(
            '''
            SELECT tess_id,name,mac_address,calibration_k,calibrated_since,calibrated_until,calibrated_state,location_id 
            FROM tess_t
            ORDER BY tess_id ASC;
            ''')
    result = cursor.fetchall()
    with open(options.file, 'w') as outfile:
        json.dump(map(instrument_map, result), outfile, indent=4, sort_keys=True)

def instrument_import(connection, options):
    cursor = connection.cursor()
    with open(options.file, 'r') as outfile:
        rows = json.load(outfile)
    cursor.executemany(
        '''INSERT OR REPLACE INTO tess_t (
            tess_id,
            name,
            mac_address,
            calibration_k,
            calibrated_since,
            calibrated_until,
            calibrated_state,
            location_id
        ) VALUES (
            :tess_id,
            :name,
            :mac_address,
            :calibration_k,
            :calibrated_since,
            :calibrated_until,
            :calibrated_state,
            :location_id
        )
        ''', rows)
    connection.commit()


def instrument_create(connection, options):
    cursor = connection.cursor()
    row = {}
    row['name']       = options.name
    row['mac']        = options.mac
    row['calib']      = options.calib
    row['calib_flag'] = CURRENT
    row['eff_date']   = datetime.datetime.utcnow().strftime(TSTAMP_FORMAT)
    row['exp_date']   = INFINITE_TIME
    
    # Find existing MAC and abort if so
    cursor.execute(
        '''
        SELECT name, mac_address, calibration_k 
        FROM tess_t 
        WHERE mac_address == :mac
        AND calibrated_state == :calib_flag
        ''', row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Already existing MAC %s" % (row['mac'],) )
    # Find existing name and abort if so
    cursor.execute(
        '''
        SELECT tess_id, mac_address, calibration_k, location_id 
        FROM tess_t 
        WHERE name == :name
        AND calibrated_state == :calib_flag 
        ''', row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Other instrument already using friendly name %s" (row['name'],) )
    # Write into database
    cursor.execute(
        '''
        INSERT INTO tess_t (
            name,
            mac_address, 
            calibration_k,
            calibrated_since,
            calibrated_until,
            calibrated_state
        ) VALUES (
            :name,
            :mac,
            :calib,
            :eff_date,
            :exp_date,
            :calib_flag
        )
        ''',  row)
    connection.commit()
    # Now display it
    cursor.execute(
        '''
        SELECT name,mac_address,calibration_k,site,longitude,latitude,elevation 
        FROM   tess_v
        WHERE  name == :name
        WHERE  calibrated_state == :calib_flag
        ''', row)
    paging(cursor,["TESS","MAC Addr.","Calibration","Site","Longitude","Latitude","Elevation"])



def instrument_rename(connection, options):
    cursor = connection.cursor()
    row = {}
    row['newname']  = options.new_name
    row['oldname']  = options.old_name
    cursor.execute("SELECT mac_address FROM tess_t WHERE name == :oldname", row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing instrument with old name %s does not exist." % (options.old_name,) )
    cursor.execute("SELECT mac_address FROM tess_t WHERE name == :newname", row)
    result = cursor.fetchone()
    if result:
        raise IndexError("Cannot rename. Existing instrument MAC %s owns this name." % (result[0],) ) 
    cursor.execute("UPDATE tess_t SET name = :newname WHERE name == :oldname", row)
    connection.commit()
    # Now display it
    row['calib_flag'] = CURRENT
    cursor.execute(
        '''
        SELECT name,mac_address,calibration_k,site,longitude,latitude,elevation 
        FROM   tess_v
        WHERE  name == :newname
        AND    calibrated_state == :calib_flag
        ''', row)
    paging(cursor,["TESS","MAC Addr.","Calibration","Site","Longitude","Latitude","Elevation"])



def instrument_update(connection, options):
    cursor = connection.cursor()
    row = {}
    row['name']       = options.name
    row['calib_flag'] = CURRENT
    cursor.execute(
        '''
        SELECT name, mac_address, location_id 
        FROM tess_t 
        WHERE name == :name
        AND calibrated_state == :calib_flag 
        ''', row)
    result = cursor.fetchone()
    if not result:
        raise IndexError("Cannot rename. Existing instrument with name %s does not exist." % (options.name,) )
    row['mac']           = result[1]
    row['location']      = result[2]
    row['calib']         = options.new_value
    row['eff_date']      = datetime.datetime.utcnow().strftime(TSTAMP_FORMAT)
    row['exp_date']      = INFINITE_TIME
    row['calib_expired'] = EXPIRED
    
    cursor.execute(
        '''
        UPDATE tess_t SET calibrated_until = :eff_date, calibrated_state = :calib_expired
        WHERE mac_address == :mac AND calibrated_state == :calib_flag
        ''', row)
    cursor.execute(
        '''
        INSERT INTO tess_t (
            name,
            mac_address, 
            calibration_k,
            calibrated_since,
            calibrated_until,
            calibrated_state,
            location_id
        ) VALUES (
            :name,
            :mac,
            :calib,
            :eff_date,
            :exp_date,
            :calib_flag,
            :location
        )
        ''',  row)
    connection.commit()
    print("Operation complete.")
    cursor.execute(
        '''
        SELECT name, calibration_k, calibrated_state, calibrated_since, calibrated_until, site
        FROM   tess_v
        WHERE  name == :name
        ''', row)
    paging(cursor,["TESS","Calibration","State","Since","Until", "Site"])


# --------------------
# LOCATION SUBCOMMANDS
# --------------------

def location_list(connection, options):
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT site,longitude,latitude,elevation 
        FROM location_t 
        WHERE location_id > -1 
        ORDER BY location_id ASC
        ''')
    paging(cursor,["Name","Longitude","Latitude","Elevation"])
   

def readings_list(connection, options):
    cursor = connection.cursor()
    cursor.execute(
        '''
        SELECT (d.sql_date || 'T' || t.time) AS timestamp, i.name, l.site, r.frequency, r.magnitude
        FROM tess_readings_t as r
        JOIN date_t     as d USING (date_id)
        JOIN time_t     as t USING (time_id)
        JOIN location_t as l USING (location_id)
        JOIN tess_t     as i USING (tess_id)
        ORDER BY r.date_id DESC, r.time_id DESC
        LIMIT %s
        ''' % options.count)
    paging(cursor, ["Timestamp (UTC)","TESS","Location","Frequency","Magnitude"], size=options.count)
   
 
main()
